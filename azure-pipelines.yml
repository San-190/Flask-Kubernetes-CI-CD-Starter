# Configure pipeline trigger to run automatically
trigger:
  # Specify branches that will trigger the pipeline
  branches:
    include:
      - master  # Only the 'master' branch triggers the pipeline
  # Specify paths that will trigger the pipeline
  paths:
    include:
      - '*'  # Any change in any file triggers the pipeline

# Define the agent pool used to run the pipeline.
# In this case, a virtual machine with Ubuntu is used.
pool:
  vmImage: ubuntu-latest

# Pipeline variables - replace the <> placeholders in Azure DevOps Pipeline variables
# or set them in a Variable Group. Do NOT store secrets here.
variables:
  imageName: <IMAGE_NAME>            # e.g. my-app-python
  registry: <ACR_REGISTRY>           # e.g. yourregistry.azurecr.io
  # Note: containerRegistry below is the name of the Azure DevOps service connection
  # configured to allow pushing to your ACR. Replace with your service connection name.
  containerRegistryServiceConnection: <DOCKER_REGISTRY_SERVICE_CONNECTION>

steps:
  # Select the Python version to use on the agent
  - task: UsePythonVersion@0
    inputs:
      versionSpec: '3.x'  # Specify any 3.x Python version
    displayName: 'Select Python 3.x'

  # Install and upgrade pip, then install project dependencies locally
  - script: |
      python -m pip install --upgrade pip
      pip install -r src/requirements.txt
    displayName: 'Install dependencies (local)'

  # Build and push the Docker image to Azure Container Registry (ACR)
  - task: Docker@2
    displayName: 'Build & Push Docker image to ACR'
    inputs:
      # Use the service connection name (placeholder above)
      containerRegistry: '$(containerRegistryServiceConnection)'
      # Define the full repository inside the ACR (registry/image name).
      repository: '$(registry)/$(imageName)'
      # Indicate the command to build and push the image.
      command: buildAndPush
      # Specify the Dockerfile location used to build the image.
      dockerfile: 'Dockerfile'
      # Define tags to assign to the Docker image.
      tags: |
        latest
        $(Build.BuildId)

  # Update k8s/deployment.yml so the referenced Docker image uses the current build tag.
  # The deployment file should contain placeholders (<ACR_REGISTRY>/<IMAGE_NAME>:<IMAGE_TAG>).
  - task: Bash@3
    displayName: 'Update deployment.yml with build tag'
    inputs:
      targetType: 'inline'
      script: |
        # Replace the placeholder image entry in the k8s manifest with built image tag.
        # This assumes the manifest contains a line like:
        #   image: <ACR_REGISTRY>/<IMAGE_NAME>:<IMAGE_TAG>
        sed -i "s|image: .*|image: $(registry)/$(imageName):$(Build.BuildId)|" k8s/deployment.yml

  - task: Kubernetes@1  # Kubernetes task to interact with the cluster
    displayName: 'Update deployment in Kubernetes'  # Descriptive task name in the pipeline
    inputs:
      connectionType: 'Azure Resource Manager'  # Connection type, here Azure Resource Manager
      # Replace the placeholders below with your Azure DevOps subscription service connection
      azureSubscriptionEndpoint: '<AZURE_SUBSCRIPTION_CONNECTION>'  # Name of the Azure subscription connection
      azureResourceGroup: '<RESOURCE_GROUP>'   # Azure resource group where the cluster resides
      kubernetesCluster: '<AKS_CLUSTER>'       # Kubernetes cluster name
      namespace: 'default'  # Kubernetes namespace where the deployment will be applied
      command: 'apply'  # Command to execute, here apply the configuration
      useConfigurationFile: true  # Indicates that a configuration file will be used
      configuration: 'k8s/deployment.yml'  # Path to the Kubernetes configuration file